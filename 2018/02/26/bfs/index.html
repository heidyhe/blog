<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="dfs,bfs,union find," />










<meta name="description" content="BFS, short for Breadth First Search, is an algorithm of searching tree or graph data structures. It starts at some specific nodes and explores the neighbor nodes first before moving to the next level,">
<meta name="keywords" content="dfs,bfs,union find">
<meta property="og:type" content="article">
<meta property="og:title" content="BFS">
<meta property="og:url" content="https://heidyhe.github.io/2018/02/26/bfs/index.html">
<meta property="og:site_name" content="Little by Little">
<meta property="og:description" content="BFS, short for Breadth First Search, is an algorithm of searching tree or graph data structures. It starts at some specific nodes and explores the neighbor nodes first before moving to the next level,">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/heidyhe/img/master/algorithm/bfs-dfs.png">
<meta property="og:updated_time" content="2018-03-27T04:21:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BFS">
<meta name="twitter:description" content="BFS, short for Breadth First Search, is an algorithm of searching tree or graph data structures. It starts at some specific nodes and explores the neighbor nodes first before moving to the next level,">
<meta name="twitter:image" content="https://raw.githubusercontent.com/heidyhe/img/master/algorithm/bfs-dfs.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://heidyhe.github.io/2018/02/26/bfs/"/>





  <title>BFS | Little by Little</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Little by Little</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Aha~, stay curious and have fun</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://heidyhe.github.io/2018/02/26/bfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Heidy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://raw.githubusercontent.com/heidyhe/img/master/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Little by Little">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">BFS</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-26T17:50:55-08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>BFS, short for Breadth First Search, is an algorithm of searching <strong>tree</strong> or <strong>graph</strong> data structures. It starts at some specific nodes and explores the neighbor nodes first before moving to the next level, until it searches through the whole graph.</p>
<p>BFS usually works with a queue.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize</span></span><br><span class="line">queue.add(node);</span><br><span class="line"><span class="comment">// search</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// Node represents a node in a graph</span></span><br><span class="line">    Node node = queue.poll();</span><br><span class="line">    <span class="comment">// explore the neighbor nodes</span></span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isQualified(neighbor)) queue.add(neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BFS and <a href="https://heidyhe.github.io/2018/02/27/dfs/">DFS</a> are two typical algorithms of searching graphs, and some searching problems can be solved by Union Find as well, so first I want to discuss the scenarios where we should use BFS, DFS or Union Find. And then I will walk through some problems, if they can be solved using DFS or Union Find, I’ll provide the corresponding solutions; otherwise, I’ll list the reasons why DFS or Union Find cannot be applied to the problems.</p>
<a id="more"></a>
<h2 id="BFS-vs-DFS"><a href="#BFS-vs-DFS" class="headerlink" title="BFS vs. DFS"></a>BFS vs. DFS</h2><p>The example below compares the way of how BFS traverses and the way of how DFS traverses, assuming that the moving directions can be right and down only.<br><img src="https://raw.githubusercontent.com/heidyhe/img/master/algorithm/bfs-dfs.png" alt="BFS vs. DFS"></p>
<p>Sometimes BFS and DFS can be used to solved the same problems. Whether BFS or DFS is a better choice, it depends. </p>
<h2 id="BFS-vs-Union-Find"><a href="#BFS-vs-Union-Find" class="headerlink" title="BFS vs. Union Find"></a>BFS vs. Union Find</h2><p>Union Find is not a searching algorithm. It partitions a set of elements into a number of non-overlapping subsets. Each element is intialized as a subset of its own, and then subsets are merged if they are of the same kind until the subsets are not overlapping. Although it is quite different than BFS, sometimes they can be used to solve the same problems.</p>
<h2 id="Problems-and-solutions"><a href="#Problems-and-solutions" class="headerlink" title="Problems and solutions"></a>Problems and solutions</h2><h3 id="i-Binary-tree"><a href="#i-Binary-tree" class="headerlink" title="i. Binary tree"></a>i. Binary tree</h3><p>Level order traversal of binary trees is an example of BFS. See more in this post about <a href="https://heidyhe.github.io/2018/02/24/binary-tree/#more">binary tree</a>.</p>
<h3 id="ii-Graph"><a href="#ii-Graph" class="headerlink" title="ii. Graph"></a>ii. Graph</h3><p><a href="https://leetcode.com/problems/01-matrix/description/" target="_blank" rel="noopener">542. 01 Matrix</a>：given a matrix which consists of 0 and 1, find the distance of the nearst 0 for each cell.</p>
<p><strong>BFS solution</strong></p>
<blockquote>
<p>Start from all the cells of 0, and explores its adjacent cells, if it is 1 and has not been processed, then update the cell’s distance to be current cell’s distance plus 1 and put it in the queue. Because the search starts from 0, the cells of 1 close to 0 must be processed before those far away from 0.<br>Time complexity: O(row * col).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the queue with cells of 0</span></span><br><span class="line">init(queue, matrix);</span><br><span class="line"><span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    Node cell = queue.poll();</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : getNeighbors(cell)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (neighbor.value == <span class="number">1</span> &amp;&amp; distance[neighbor.row][neighbor.col] == <span class="number">0</span>) &#123;</span><br><span class="line">            distance[neighbor.row][neighbor.col] = distance[cell.row][cell.pol] + <span class="number">1</span>;</span><br><span class="line">            queue.add(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS solution</strong></p>
<blockquote>
<p>Since this problem is about finding the shortest distance from 1, DFS has to start from the cells of 1 adjacent to 0, and then it updates the distance of each 1 on the searching path if the length of the path is the shortest until it cannot find any cells which meet the update requirements. The time complexity is O(row <em> col </em> k) where k depends on the length of the searching paths.<br>BFS is a better solution for this problem.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] updated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] neighbors = getNeighbors(i, j, row, col);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; neighbors.length; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nI = neighbors[k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nJ = neighbors[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nI &gt; -<span class="number">1</span> &amp;&amp; nJ &gt; -<span class="number">1</span> &amp;&amp; matrix[nI][nJ] == <span class="number">1</span> &amp;&amp; dist + <span class="number">1</span> &lt; updated[nI][nJ]) &#123;</span><br><span class="line">            updated[nI][nJ] = dist + <span class="number">1</span>;</span><br><span class="line">            dfs(nI, nJ, dist + <span class="number">1</span>, row, col, matrix, updated);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Union Find solution</strong></p>
<blockquote>
<p>This problem cannot be handled by the Union Find algorithm, because the union of the matrix cells cannot solve the problem. </p>
</blockquote>
<h3 id="iii-Graph"><a href="#iii-Graph" class="headerlink" title="iii. Graph"></a>iii. Graph</h3><p><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/description" target="_blank" rel="noopener">417. Pacific Atlantic Water Flow</a>.</p>
<p><strong>BFS solution</strong> </p>
<blockquote>
<p>It is obvious that the cells on the top right corner and bottom left corner are where water can flow to both the Pacific ocean and Atlantic ocean, the cells on the first row and first column are where water can flow to the Pacific ocean, and the cells on the last row and last column are where water can flow to the Atlantic ocean, so these are the cells to begin with in a search. If a cell is no higher than its neighbor cell, which means water can flow from the neighbor cell to the current cell, its neighbor cell’s status might need to be updated according to the status of current cell; and if the neighbor cell’s status is updated, it should be put into the queue because the update might affect its surrounding cells’ status.<br>For each cell, its status will be updated at most twice, so the time complexity is O(m * n).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] mark = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"><span class="comment">// cells in the first row and first column are initialized as 1 for Pacific</span></span><br><span class="line"><span class="comment">// cells in the last row and last column are initialized as 2 for Atlantic</span></span><br><span class="line"><span class="comment">// [0, n-1] and [m-1, 0] are initialized as 3 for both Pacific and Atlantic</span></span><br><span class="line"><span class="comment">// put these initialized cells in the queue</span></span><br><span class="line">init(mark, matrix, queue);</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    Node node = queue.poll();</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : getNeighbors(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.height &lt;= neighbor.height) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> updated = updateMark(neighbor, node);</span><br><span class="line">            <span class="keyword">if</span> (updated) &#123; queue.put(neighbor); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS solution</strong></p>
<blockquote>
<p>The key of DFS is to know which cells to start a search and the ending conditions for each search.<br>Both BFS and DFS are proper solutions for this problem. There is no difference in time complexity.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cells to start a DFS</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    dfs(i, <span class="number">0</span>, row, col, matrix, mark);</span><br><span class="line">    dfs(i, col - <span class="number">1</span>, row, col, matrix, mark);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    dfs(<span class="number">0</span>, j, row, col, matrix, mark);</span><br><span class="line">    dfs(row - <span class="number">1</span>, j, row, col, matrix, mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[][] mark)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d.length; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nI = i + d[k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nJ = j + d[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nI &gt;= <span class="number">0</span> &amp;&amp; nI &lt; row &amp;&amp; nJ &gt;= <span class="number">0</span> &amp;&amp; nJ &lt; col &amp;&amp; matrix[i][j] &lt;= matrix[nI][nJ]</span><br><span class="line">                &amp;&amp; mark[nI][nJ] != (mark[i][j] | mark[nI][nJ])) &#123;</span><br><span class="line">            mark[nI][nJ] = mark[i][j] | mark[nI][nJ];</span><br><span class="line">            dfs(nI, nJ, row, col, matrix, mark);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Union Find solution</strong></p>
<blockquote>
<p>For this problem, Union Find is not a proper solution because a cell marked for “Pacific” can be changed to “Pacific-Atlantic” later and yet Union is just a process of merging without moving one element from one subset to another.</p>
</blockquote>
<h3 id="iv-Graph"><a href="#iv-Graph" class="headerlink" title="iv. Graph"></a>iv. Graph</h3><p><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="noopener">130. Surrounded Regions</a>: given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’.</p>
<p><strong>BFS solution</strong></p>
<blockquote>
<p>If an ‘O’ is at the edges, it cannot be captured, so we can start from the ‘O’s at the edges, and mark other ‘O’s which are connected to these ‘O’. The ‘O’s left are the ones which are captured.<br>The time complexity depends on the number of ‘O’, so it is O(n) suppose the matrix contains <em>n</em> elements.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put all the 'O's at the edges in the queue</span></span><br><span class="line">init(queue, matrix);</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    Node node = queue.poll();</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : getNeighbors(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (neighbor.value == <span class="string">'O'</span>) &#123;</span><br><span class="line">            matrix[neighbor.row][neighbor.col] = <span class="string">'A'</span>;</span><br><span class="line">            queue.add(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS solution</strong></p>
<blockquote>
<p>The idea is similar to BFS, also starting from all ‘O’s at the edges and marking all the ‘O’s on the path until ‘X’ is encountered. The time complexity is O(n).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node node : nodeAtEdges) &#123;</span><br><span class="line">    dfs(node, matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, <span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : getNeighbors(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (neighbor.value == <span class="string">'O'</span>) &#123;</span><br><span class="line">            matrix[neighbor.row][neighbor.col] = <span class="string">'A'</span>;</span><br><span class="line">            dfs(neighbor, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Union Find solution</strong></p>
<blockquote>
<p>There are two kinds of ‘O’ in this problem, those are surrounded by ‘X’ and those aren’t. Initially, each ‘O’ is the root of its own subset. During the process, if two cells are adjacent but they belong to different subsets, those two subsets are merged. In the end, what we have is that all the ‘O’s are divided into different subsets, some are surrounded by ‘X’ and the others aren’t. So we only need to change all the ‘O’s in the subsets whose root is not at the edge.<br>The time complexity is O(k * n), where k depends on the time complexity of the Find function.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> root = find(i, j, parent);</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : getNeighbors(i, j)) &#123;</span><br><span class="line">            <span class="keyword">int</span> nI = neighbor.row;</span><br><span class="line">            <span class="keyword">int</span> nJ = neighbor.col;</span><br><span class="line">            <span class="keyword">if</span> (matrix[nI][nJ] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> nRoot = find(nI, nJ, parent);</span><br><span class="line">            <span class="keyword">if</span> (root != nRoot) &#123;</span><br><span class="line">                <span class="comment">// union</span></span><br><span class="line">                <span class="keyword">if</span> (isAtEdge(root)) &#123;</span><br><span class="line">                    parent[nRoot] = root;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[root] = nRoot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> root = find(i, j, parent);</span><br><span class="line">        <span class="keyword">if</span> (!isAtEdge(root)) &#123;</span><br><span class="line">            matrix[i][j] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="v-Graph"><a href="#v-Graph" class="headerlink" title="v. Graph"></a>v. Graph</h3><p><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">200. Number of Islands</a>: count the number of islands; an island is surrounded by ‘0’s and is formed by connecting adjacent ‘1’s.</p>
<p><strong>BFS solution</strong></p>
<blockquote>
<p>Start from any ‘1’ that has not been processed, explore the ‘1’s that can form an island and mark them as processed.<br>Time complexity is O(n), suppose the matrix contains <em>n</em> elements.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countIslands</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] mark = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span> &amp;&amp; mark[i][j] = <span class="number">0</span>) &#123;</span><br><span class="line">                mark[i][j] = <span class="number">1</span>;</span><br><span class="line">                bfs(i, j, mark, matrix);</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] mark, <span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    queue.add(<span class="keyword">new</span> Node(i, j));</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node current = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : getNeighbors(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[neighbor.row][neighbor.col] == <span class="string">'1'</span> </span><br><span class="line">                &amp;&amp; mark[neighbor.row][neighbor.col] == <span class="number">0</span>) &#123;</span><br><span class="line">                mark[neighbor.row][neighbor.col] = <span class="number">1</span>;</span><br><span class="line">                queue.add(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS solution</strong></p>
<blockquote>
<p>The idea is similar to BFS - start from any ‘1’ that has not been processed, explore the ‘1’s that can form an island and mark them as processed. It is that only the way of search differs.<br>The time complexity is O(n) as well.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the function bfs() above can be replaced by this function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, <span class="keyword">int</span>[][] mark, <span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node neighbor : getNeighbors(node)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[neighbor.row][neighbor.col] == <span class="string">'1'</span> &amp;&amp; mark[neighbor.row][neighbor.col] == <span class="number">0</span>) &#123;</span><br><span class="line">            mark[neighbor.row][neighbor.col] = <span class="number">1</span>;</span><br><span class="line">            dfs(neighbor, mark, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Union Find solution</strong></p>
<blockquote>
<p>For the cells that form an island, they belong to the same subset. So the solution is to apply the Union Find algorithm to this problem and then find out how many subsets are there.<br>The time complexity is O(k <em> n), where </em>k<em> depends on the </em>find* function.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[row * col];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = find(i, j); <span class="comment">// find</span></span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : getNeighbors(i, j)) &#123;</span><br><span class="line">            <span class="keyword">int</span> nI = neighbor.row;</span><br><span class="line">            <span class="keyword">int</span> nJ = neighbor.col;</span><br><span class="line">            <span class="keyword">if</span> (matrix[nI][nJ] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> nRoot = find(nI, nJ); <span class="comment">// find</span></span><br><span class="line">            <span class="keyword">if</span> (root != nRoot) &#123;</span><br><span class="line">                parent[root] = nRoot; <span class="comment">// union</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follow-up: <a href="https://www.programcreek.com/2015/01/leetcode-number-of-islands-ii-java/" target="_blank" rel="noopener">Numbers of Islands II</a>.</p>
<p>The Union Find algorithm is more suitable for solving this problem. For each operation, we only need to check the four adjacent cells of the new position and then count the number of subset. But if we use BFS or DFS, the time complexity will become unacceptable for it depends on the number of operations.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/dfs/" rel="tag"># dfs</a>
          
            <a href="/tags/bfs/" rel="tag"># bfs</a>
          
            <a href="/tags/union-find/" rel="tag"># union find</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/25/big-number/" rel="next" title="Math Problems with Big Numbers">
                <i class="fa fa-chevron-left"></i> Math Problems with Big Numbers
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/27/dfs/" rel="prev" title="DFS">
                DFS <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://raw.githubusercontent.com/heidyhe/img/master/avatar.jpg"
                alt="Heidy" />
            
              <p class="site-author-name" itemprop="name">Heidy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/heidyhe" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:heidycat@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS-vs-DFS"><span class="nav-text">BFS vs. DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS-vs-Union-Find"><span class="nav-text">BFS vs. Union Find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problems-and-solutions"><span class="nav-text">Problems and solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#i-Binary-tree"><span class="nav-text">i. Binary tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ii-Graph"><span class="nav-text">ii. Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iii-Graph"><span class="nav-text">iii. Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iv-Graph"><span class="nav-text">iv. Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#v-Graph"><span class="nav-text">v. Graph</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Heidy</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
